#!/usr/bin/env python3

import numpy as np
import matplotlib.pyplot as plt

from scipy.stats import multivariate_normal
from mpl_toolkits.mplot3d import Axes3D
import pandas as pd
import math
from collections import Counter
from geometry_msgs.msg import PoseStamped

import sys
import os
# #Parameters to set
# mu_x = 0
# variance_x = 20

# mu_y = 0
# variance_y = 20

# #Create grid and multivariate normal
# x = np.linspace(-10,10,500)
# y = np.linspace(-10,10,500)
# X, Y = np.meshgrid(x,y)
# pos = np.empty(X.shape + (2,))
# pos[:, :, 0] = X; pos[:, :, 1] = Y
# rv = multivariate_normal([mu_x, mu_y], [[variance_x, 0], [0, variance_y]])

# #Make a 3D plot
# fig = plt.figure()
# ax = fig.gca(projection='3d')
# ax.plot_surface(X, Y, rv.pdf(pos),cmap='viridis',linewidth=0)
# ax.set_xlabel('X axis')
# ax.set_ylabel('Y axis')
# ax.set_zlabel('Z axis')
# plt.show()

# a=np.ones([5,5])
# print(a)
# b= np.array([[1,1], [2,2], [4,4]])
# print(b)
# c=[10,10,10]
# print(c)
# for i in range(len(b)):
#     [ind, ind2]=b[i]
#     a[ind, ind2]= c[i]
# print(a)

# from collections import Counter
# angle_received=6
# arr1= np.random.normal(loc=360, scale= 20 , size=360)
# print(np.amax(arr1))
# print("randomly generated array", arr1)
# arr1= np.round(arr1).astype(int)
# # print("arr1 after round", arr1)
# ind_arr= Counter(arr1)# Counting the occurance of values generated by random.normal
# # print("ind_arr is:", ind_arr)
# prob= np.zeros(360,dtype='int32') # Should I convert zeros to 0.00001 ?
# prob= prob.astype(int)
# # prob=[ind_arr[ele] for ele in ind_arr]

# for ele in ind_arr:    
#   prob[ele]= ind_arr[ele]
# # print("generated probability is:", prob)
# ## Dividing the array values by sum of events to convert the counts to probabilities
# prob_sum= np.sum(prob)
# prob= np.divide(prob, prob_sum)
# non_zero_ind=np.argwhere(prob>0)

# print()
# print("new probability:", prob)
# print("sum of prob:  ", np.sum(prob))# confirming that sum of probabilities is 1

# plt.plot(range(len(prob)), prob)
# plt.show()






# mean1=200
# mean2=200
# dim1=400
# dim2=400
# val = 50
# mean = np.array([mean1,mean2])
# cov = np.array([[val,1], [1, val]])
# distr = multivariate_normal(cov = cov, mean = mean)#,seed = random_seed)
# data = distr.rvs(size = 9000)
# print("First 5 values before rounding are:  ",data[0:5,:])
# data=np.round(data)
# print("First 5 values after rounding are:  ",data[0:5,:])
#    # We need to disregard values which are out of bounds of map
#    # anything more than 3999 and less than 0 as of now and dim1,2 later
# df = pd.DataFrame(data, columns = ['A','B'])
# df = df[df['A'].between(0, dim1-1)]
# df = df[df['B'].between(0, dim2-1)]
# data= df.to_numpy()
# data=np.abs(data)
# print("data after removing outbounds",data)
# b = np.ascontiguousarray(data).view(np.dtype((np.void, data.dtype.itemsize * data.shape[1])))
# unq_data, unq_cnt = np.unique(b, return_counts=True)
# unq_data = unq_data.view(data.dtype).reshape(-1, data.shape[1])
# prob=np.zeros([dim1,dim2], dtype=float) # Taking ones matrix instead of zero to provide minimal prob to all pixels 
#    # counter=0
  
# unq_data=unq_data.astype(np.int)
# unq_cnt=unq_cnt ##Adding one to all counts :)
# print("unq_data is: ", unq_data[np.argmax(unq_cnt)])
# print("unq_cnt is: ", unq_cnt[np.argmax(unq_cnt)])
# prob[unq_data[:,0], unq_data[:,1]] = unq_cnt
# print("mat count is: ",prob)
# prob=np.divide(prob, np.sum(prob))
# print("prob matrix sum is: ", np.sum(prob))
# x = range(len(prob))
# y = range(len(prob))
# # data = numpy.random.random((nx, ny))
# hf = plt.figure()
# ha = hf.add_subplot(111, projection='3d')
# X, Y = np.meshgrid(x, y)  # `plot_surface` expects `x` and `y` data to be 2D
# ha.plot_surface(X, Y, prob)
# print("Max prob value is: ",np.amax(prob))
# print("Min prob value is: ",np.amin(prob))
# # print(" 50 Values near point", prob[990:1010, 990:1010])
# # print("Values which are not 1")
# plt.show()
# plt.plot(range(prob[0,:]),range(prob[:,1]), 'o', c='lime',
#             markeredgewidth = 0.5,
#             markeredgecolor = 'black')
# plt.show()

# dir=np.array([40,50, 60, 70, 80, 90])
# # noise= np.random.normal(0,4.5,100)
# direction=60
# arr1= np.random.normal(loc=direction, scale= 13 , size=4000)
# arr1= np.round(arr1)
# arr1= arr1%360  # Circulating all values into continous angles of range(0-360)
# arr1= arr1.astype(int)
# ind_arr= Counter(arr1)
# prob= np.zeros(360,dtype='int32')
# for ele in ind_arr:    
#   prob[ele]= ind_arr[ele]
# prob= np.divide(prob, np.sum(prob))

# dir=np.round(dir)
# prob2= prob[dir]
# print("probability of 4 given angles is", prob2)
# prob2= np.divide(prob2, np.sum(prob2))
# print("probability after normalization is:, ", prob2)
# print("Sum check:", np.sum(prob2))

# arr1= np.array([[1,2,3,4],[5,6,7,8],[9,9,10,11]])
# at_= np.argwhere((arr1[:,1]==9) & (arr1[:,2]==11))
# if len(at_)>0:
#     print(at_)
# y_at=np.argwhere(arr1[:,2]==10)
# x_at=
# print(x_at)
print(os.environ)