import numpy as np
import matplotlib.pyplot as plt

from scipy.stats import multivariate_normal
from mpl_toolkits.mplot3d import Axes3D
import pandas as pd
import math
from collections import Counter
angle_received=60
arr1= np.random.normal(loc=angle_received, scale=13 , size=4000)
# print("randomly generated array", arr1)
arr1= np.round(arr1).astype(int)
arr1= arr1%360
# print("arr1 after round", arr1)
ind_arr= Counter(arr1)# Counting the occurance of values generated by random.normal
# print("ind_arr is:", ind_arr)
prob= np.zeros(360,dtype='int32') # Should I convert zeros to 0.00001 ?
prob= prob.astype(int)
# prob=[ind_arr[ele] for ele in ind_arr]

for ele in ind_arr:    
  prob[ele]= ind_arr[ele]
# print("generated probability is:", prob)
## Dividing the array values by sum of events to convert the counts to probabilities
prob_sum= np.sum(prob)
prob= np.divide(prob, prob_sum)
non_zero_ind=np.squeeze(np.argwhere(prob>0))
print("non_zero_ind is",non_zero_ind)
rang=range(non_zero_ind[0],non_zero_ind[-1])
# print(prob[rang])
##########################################
map1=np.ones([400,400])
gauss_val= prob[rang]
print("gaussian value for ",gauss_val)
# print("sum of first 3 values is: ",sum(gauss_val[0:4]))
curr_cell=[50,50] # current position of robot on map pixels
[i,j]= curr_cell
# print(i,j)
# angle_received= -30
first_slopes= np.zeros(len(gauss_val))
first_slopes[np.argmax(gauss_val)]= angle_received
first_slopes[0:np.argmax(gauss_val)] = angle_received + 90
first_slopes[np.argmax(gauss_val)+1:] = angle_received - 90
first_values= np.zeros([2,len(gauss_val)])
print("first values created", first_values)
first_values[0,:]= np.sin(np.radians(first_slopes))
first_values[1,:]= np.cos(np.radians(first_slopes))
first_values[:,np.argmax(gauss_val)]= np.array(curr_cell).T # Assign cell value to current cell
print("center pixel value with unit slopes", first_values)
dy= first_values[0,:].tolist()
dx= first_values[1,:].tolist()
for i in range(np.argmax(gauss_val)):   # For values left of mean
    dy[i]= sum(dy[i:np.argmax(gauss_val)+1])
    dx[i]= sum(dx[i:np.argmax(gauss_val)+1])
    print("iteration number, dy[iter], dx[iter]", i, dy[i],dx[i])
for i in range(len(gauss_val),np.argmax(gauss_val),-1): # for values right to mean
    dy[i-1]= sum(dy[np.argmax(gauss_val):i])
    dx[i-1]= sum(dx[np.argmax(gauss_val):i])
    print("iteration number, dy[iter], dx[iter]", i, dy[i-1],dx[i-1])
first_values= np.row_stack((np.array(dy),np.array(dx)))
print("first_values after adding angles to center pixel", first_values)
first_values=np.round(first_values)
print("first values afer ronding off: ", first_values)
first_values=first_values.astype(int).T
print("conirming transpose", first_values)
print("shape of first_values and gauss_val", first_values.shape, gauss_val.shape)
tbd= np.argwhere(first_values<0)

tbd= np.append(tbd, np.argwhere(first_values>=len(map1)), axis=0)
first_values= np.delete(first_values, tbd[:,0], 0)
gauss_val= np.delete(gauss_val, tbd[:,0], 0)
map1[first_values[:,1], first_values[:,0]]= gauss_val +1 # Here +1

# Now extend first_values in direction of angle_received 
dy_input= np.sin(np.radians(angle_received))
dx_input= np.cos(np.radians(angle_received))
[i,j]= curr_cell

for k in range(len(first_values)):
    i=first_values[k,0]
    j= first_values[k,1]
    counter=1
    while((i>=0 and i<len(map1)) and (j>=0 and j<len(map1))):
        i=round(i + counter*dy_input)
        j=round(j + counter*dx_input)
        print("newx,y", j,i)
        if ((i>=0 and i<len(map1)) and (j>=0 and j<len(map1))):
            map1[j,i]= gauss_val[k]+1
            print(gauss_val[k])
        counter+=1
map1= np.divide(map1, np.sum(map1))
print("total map1 is:", np.sum(map1))
# print("updated map cutout is:", map1[0:50,0:50])
x = range(len(map1))
y = range(len(map1))
hf = plt.figure()
ha = hf.add_subplot(111, projection='3d')
X, Y = np.meshgrid(x, y)  # `plot_surface` expects `x` and `y` data to be 2D
ha.plot_surface(X, Y, map1)
print("max prob value", np.amax(map1))
print("Min prob value is: ",np.amin(map1))
# print("SOme values near curr_cell", map1[])
plt.show()
