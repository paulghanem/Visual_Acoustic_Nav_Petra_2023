#!/usr/bin/env python3

# Importing the necessary modules
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import multivariate_normal
import itertools
from collections import Counter
import pandas as pd
from sklearn import preprocessing
import rospy
from std_msgs.msg import Int32, Int32MultiArray, Float32MultiArray
from geometry_msgs.msg import PoseStamped
import tf_conversions
import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from rospy.numpy_msg import numpy_msg
from rospy_tutorials.msg import Floats


prob1= np.array(10)
map_index=Int32MultiArray()
bad_bool=False

def create_pdf(dim1,dim2, mean1, mean2):
    val = 10
    mean = np.array([mean1,mean2])
    cov = np.array([[val,1], [1, val]])
    distr = multivariate_normal(cov = cov, mean = mean)#,seed = random_seed)
    data = distr.rvs(size = 5000)
    data=np.round(data)
    # We need to disregard values which are out of bounds of map
    # anything more than 3999 and less than 0 as of now and dim1,2 later

    df = pd.DataFrame(data, columns = ['A','B'])
    df = df[df['A'].between(0, dim1-1)]
    df = df[df['B'].between(0, dim2-1)]
    data= df.to_numpy()
    data=np.abs(data)
    # print("data after removing outbounds",data)
    b = np.ascontiguousarray(data).view(np.dtype((np.void, data.dtype.itemsize * data.shape[1])))
    unq_data, unq_cnt = np.unique(b, return_counts=True)
    unq_data = unq_data.view(data.dtype).reshape(-1, data.shape[1])

    prob=np.ones([dim1,dim2]) # Taking ones matrix instead of zero to provide minimal prob to all pixels 
    # counter=0
    
    unq_data=unq_data.astype(np.int)
    unq_cnt=unq_cnt + 1 ##Adding one to all counts :) ### Removing 1 for now
    # print("unq_data is: ", unq_data[np.argmax(unq_cnt)])
    # print("unq_cnt is: ", unq_cnt[np.argmax(unq_cnt)])
    prob[unq_data[:,0], unq_data[:,1]] = unq_cnt
    # print("mat count is: ",prob)
    prob=np.divide(prob, np.sum(prob))
    print("min value of prob(bivariate)- is:", np.amin(prob))
    print("max value of prob(bivariate) is:", np.amax(prob))
    # print("prob matrix sum is: ", np.sum(prob))
    
    return prob
def directional_pdf(dim1, dim2, cur_x, cur_y, angle_received):
    arr1= np.random.normal(loc=angle_received, scale= 3 , size=4000)
    arr1= np.round(arr1).astype(int)# rounding to int degrees to end decimal due to min degree being 1deg
    arr1= arr1%360
    ind_arr= Counter(arr1)# Counting the occurance of values generated by random.normal
    # print("ind_arr is:", ind_arr)
    prob= np.ones(360,dtype='int32') # Should I convert zeros to 0.00001 ?
    prob= prob.astype(int)
    for ele in ind_arr:    
        prob[ele]= ind_arr[ele] + 1 # Adding 1 as min value is 1 to prevent 0
    # print("generated probability is:", prob)
    ## Dividing the array values by sum of events to convert the counts to probabilities
    prob_sum= np.sum(prob)
    prob= np.divide(prob, prob_sum)
    non_zero_ind=np.squeeze(np.argwhere(prob>0))
    # print("non_zero_ind is",non_zero_ind)
    rang=range(non_zero_ind[0],non_zero_ind[-1])
    # print(prob[rang])
    ##########################################
    map1=np.ones([dim1,dim2]) #####ones
    gauss_val= prob[rang]
    # print("gaussian value for ",gauss_val)
    # print("sum of first 3 values is: ",sum(gauss_val[0:4]))
    curr_cell=[cur_x,cur_y] # current position of robot on map pixels
    [i,j]= curr_cell
    # print(i,j)
    # angle_received= -30
    first_slopes= np.zeros(len(gauss_val))
    first_slopes[np.argmax(gauss_val)]= angle_received
    first_slopes[0:np.argmax(gauss_val)] = angle_received + 90
    first_slopes[np.argmax(gauss_val)+1:] = angle_received - 90
    first_values= np.zeros([2,len(gauss_val)])
    # print("first values created", first_values)
    first_values[0,:]= np.sin(np.radians(first_slopes))
    first_values[1,:]= np.cos(np.radians(first_slopes))
    first_values[:,np.argmax(gauss_val)]= np.array(curr_cell).T # Assign cell value to current cell
    # print("center pixel value with unit slopes", first_values)
    dy= first_values[0,:].tolist()
    dx= first_values[1,:].tolist()
    for i in range(np.argmax(gauss_val)):   # For values left of mean
        dy[i]= sum(dy[i:np.argmax(gauss_val)+1])
        dx[i]= sum(dx[i:np.argmax(gauss_val)+1])
        # print("iteration number, dy[iter], dx[iter]", i, dy[i],dx[i])
    for i in range(len(gauss_val),np.argmax(gauss_val),-1): # for values right to mean
        dy[i-1]= sum(dy[np.argmax(gauss_val):i])
        dx[i-1]= sum(dx[np.argmax(gauss_val):i])
        # print("iteration number, dy[iter], dx[iter]", i, dy[i-1],dx[i-1])
    first_values= np.row_stack((np.array(dy),np.array(dx)))
    # print("first_values after adding angles to center pixel", first_values)
    first_values=np.round(first_values)
    # print("first values afer ronding off: ", first_values)
    first_values=first_values.astype(int).T
    # print("conirming transpose", first_values)
    # print("shape of first_values and gauss_val", first_values.shape, gauss_val.shape)
    tbd= np.argwhere(first_values<0)
    tbd= np.append(tbd, np.argwhere(first_values>=len(map1)), axis=0)
    first_values= np.delete(first_values, tbd[:,0], 0)
    gauss_val= np.delete(gauss_val, tbd[:,0], 0)
    map1[first_values[:,1], first_values[:,0]]= gauss_val + 1 ## Removing 1 for now

    # Now extend first_values in direction of angle_received 
    dy_input= np.sin(np.radians(angle_received))
    dx_input= np.cos(np.radians(angle_received))
    [i,j]= curr_cell

    for k in range(len(first_values)):
        i=first_values[k,0]
        j= first_values[k,1]
        counter=1
        while((i>=0 and i<len(map1)) and (j>=0 and j<len(map1))):
            i=round(i + counter*dy_input)
            j=round(j + counter*dx_input)
            # print("newx,y", j,i)
            if ((i>=0 and i<len(map1)) and (j>=0 and j<len(map1))):
                map1[j,i]= gauss_val[k]+1
                # print(gauss_val[k])
            counter+=1
    map1= np.divide(map1, np.sum(map1))
    print("min value of map1(directional univariate) is:", np.amin(map1))
    print("max value of map1(directional univariate) is:", np.amax(map1))
    # print("total map1 is:", np.sum(map1))
    return map1

def callback(datacell):
    # datacell.data[0]
    mean1= datacell.data[1]
    mean2= datacell.data[2]
    # res= datacell.data[3]
    dim1= datacell.data[4]
    dim2= datacell.data[5]
    dim1= int(dim1)
    dim2= int(dim2)
    print(" Goal pixel 1, 2 received is: ", mean1, mean2)
    global prob1
    global map_index
    global bad_bool
    if len(datacell.data)==8:
        print("Will call directional pdf maker")
        z_rot= datacell.data[6]
        w_rot= datacell.data[7]
        z_angle= tf_conversions.transformations.euler_from_quaternion([0.0,0.0,z_rot, w_rot])
        z_angle= np.rad2deg(z_angle)
        print("angle received:", z_angle)
        if prob1.size==10:
            prob1= directional_pdf(dim1,dim2, mean1,mean2, z_angle[-1])
        else:
            prob2=directional_pdf(dim1,dim2, mean1,mean2, z_angle[-1])
            prob2= prob2*(np.amax(prob1)-np.amax(prob2))
            prob1= np.multiply(prob1,prob2)
            # prob1= np.add(prob1,prob2)
            prob1=np.divide(prob1,np.sum(prob1))
        indices= np.unravel_index(np.argmax(prob1, axis=None), prob1.shape)
        # np.argmax gives flattened array indices so using unravel_index
        print("Map pxel values:", indices)
        # map_index.data= indices[0] + dim2*indices[1]
        map_index.data=indices
        bad_bool=True
    elif len(datacell.data)==6:
        print("Received goal so calling create_pdf for bivariate Gauss")
        if prob1.size==10: # random size 10 indicates that this is the first time its generating probability array
            # print("prob1 size is: ",prob1.size)
            prob1= create_pdf(dim1,dim2, mean1, mean2)
        else:
            prob2=create_pdf(dim1,dim2, mean1, mean2)
            prob1= np.multiply(prob1,prob2)
            prob1=np.divide(prob1,np.sum(prob1))
        indices= np.unravel_index(np.argmax(prob1, axis=None), prob1.shape)
        print("Map pixel Values:", indices)
        # map_index.data= indices[0] + dim2*indices[1]
        map_index.data=indices
        bad_bool=True
    


def setItFalse():
    global bad_bool
    bad_bool= False
        
def bad_bool_status():
    global bad_bool
    if bad_bool:
        return True
    else:
        return False

if __name__ == '__main__':
    rospy.init_node('bivariate_node', anonymous=True)
    print("Entered system waiting for mean_index_cell")
    rospy.Subscriber("/mean_index_cell", Float32MultiArray, callback)
    # rospy.Publisher('Initial_goal', PoseStamped, queue_size=10)
    pub =rospy.Publisher("prob_goal_index", Int32MultiArray, queue_size=10)
    # pub2=rospy.Publisher("new_prob_map",numpy_msg(Floats),queue_size=1000)
    while not rospy.is_shutdown():
        if bad_bool_status():
            pub.publish(map_index)
            # prob2= np.reshape(prob1, 16000000)
            # pub2.publish(prob1)
            setItFalse()
    rospy.spin()
